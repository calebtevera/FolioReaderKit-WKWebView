<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/FolioReaderAddHighlightNote.swift">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/FolioReaderAddHighlightNote.swift" />
              <option name="originalContent" value="//&#10;//  FolioReaderAddHighlightNote.swift&#10;//  FolioReaderKit&#10;//&#10;//  Created by ShuichiNagao on 2018/05/06.&#10;//&#10;&#10;import UIKit&#10;import RealmSwift&#10;&#10;class FolioReaderAddHighlightNote: UIViewController {&#10;&#10;    var textView: UITextView!&#10;    var highlightLabel: UILabel!&#10;    var scrollView: UIScrollView!&#10;    var containerView = UIView()&#10;    var highlight: Highlight!&#10;    var highlightSaved = false&#10;    var isEditHighlight = false&#10;    var resizedTextView = false&#10;    &#10;    private var folioReader: FolioReader&#10;    private var readerConfig: FolioReaderConfig&#10;    &#10;    init(withHighlight highlight: Highlight, folioReader: FolioReader, readerConfig: FolioReaderConfig) {&#10;        self.folioReader = folioReader&#10;        self.highlight = highlight&#10;        self.readerConfig = readerConfig&#10;        &#10;        super.init(nibName: nil, bundle: Bundle.frameworkBundle())&#10;    }&#10;    &#10;    required init?(coder aDecoder: NSCoder) {&#10;        fatalError(&quot;storyboards are incompatible with truth and beauty&quot;)&#10;    }&#10;    &#10;    // MARK: - life cycle methods&#10;    &#10;    override func viewDidLoad() {&#10;        super.viewDidLoad()&#10;        &#10;        setCloseButton(withConfiguration: readerConfig)&#10;        prepareScrollView()&#10;        configureTextView()&#10;        configureLabel()&#10;        configureNavBar()&#10;        configureKeyboardObserver()&#10;    }&#10;    &#10;    override func viewWillAppear(_ animated: Bool) {&#10;        super.viewWillAppear(animated)&#10;        &#10;        textView.becomeFirstResponder()&#10;        setNeedsStatusBarAppearanceUpdate()&#10;    }&#10;    &#10;    override func viewDidLayoutSubviews() {&#10;        super.viewDidLayoutSubviews()&#10;        &#10;        scrollView.frame = view.bounds&#10;        containerView.frame = view.bounds&#10;        scrollView.contentSize = view.bounds.size&#10;    }&#10;    &#10;    override func viewWillDisappear(_ animated: Bool) {&#10;        super.viewWillDisappear(animated)&#10;        &#10;        if !highlightSaved &amp;&amp; !isEditHighlight {&#10;            guard let currentPage = folioReader.readerCenter?.currentPage else { return }&#10;            currentPage.webView?.js(&quot;removeThisHighlight()&quot;) { _ in }&#10;        }&#10;    }&#10;    &#10;    // MARK: - private methods&#10;    &#10;    private func prepareScrollView(){&#10;        scrollView = UIScrollView()&#10;        scrollView.delegate = self as UIScrollViewDelegate&#10;        scrollView.contentSize = CGSize.init(width: view.frame.width, height: view.frame.height )&#10;        scrollView.bounces = false&#10;        &#10;        containerView = UIView()&#10;        containerView.backgroundColor = .white&#10;        scrollView.addSubview(containerView)&#10;        view.addSubview(scrollView)&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: scrollView!, attribute: .left, relatedBy: .equal, toItem: view, attribute: .left, multiplier: 1.0, constant: 0)&#10;        let rightConstraint = NSLayoutConstraint(item: scrollView!, attribute: .right, relatedBy: .equal, toItem: view, attribute: .right, multiplier: 1.0, constant: 0)&#10;        let topConstraint = NSLayoutConstraint(item: scrollView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1, constant: 0)&#10;        let botConstraint = NSLayoutConstraint(item: scrollView, attribute: .bottom, relatedBy: .equal, toItem: view, attribute: .bottom, multiplier: 1, constant: 0)&#10;        &#10;        view.addConstraints([leftConstraint, rightConstraint, topConstraint, botConstraint])&#10;    }&#10;    &#10;    private func configureTextView(){&#10;        textView = UITextView()&#10;        textView.delegate = self&#10;        textView.translatesAutoresizingMaskIntoConstraints = false&#10;        textView.textColor = .black&#10;        textView.font = UIFont.boldSystemFont(ofSize: 15)&#10;        containerView.addSubview(textView)&#10;        &#10;        if isEditHighlight {&#10;             textView.text = highlight.noteForHighlight&#10;        }&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: textView!, attribute: .left, relatedBy: .equal, toItem: containerView, attribute: .left, multiplier: 1.0, constant: 20)&#10;        let rightConstraint = NSLayoutConstraint(item: textView!, attribute: .right, relatedBy: .equal, toItem: containerView, attribute: .right, multiplier: 1.0, constant: -20)&#10;        let topConstraint = NSLayoutConstraint(item: textView, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1, constant: 100)&#10;        let heiConstraint = NSLayoutConstraint(item: textView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: view.frame.height - 100)&#10;        &#10;        containerView.addConstraints([leftConstraint, rightConstraint, topConstraint, heiConstraint])&#10;    }&#10;    &#10;    private func configureLabel() {&#10;        highlightLabel = UILabel()&#10;        highlightLabel.translatesAutoresizingMaskIntoConstraints = false&#10;        highlightLabel.numberOfLines = 3&#10;        highlightLabel.font = UIFont.systemFont(ofSize: 15)&#10;        highlightLabel.text = highlight.content.stripHtml().truncate(250, trailing: &quot;...&quot;).stripLineBreaks()&#10;        &#10;        containerView.addSubview(self.highlightLabel!)&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: highlightLabel!, attribute: .left, relatedBy: .equal, toItem: containerView, attribute: .left, multiplier: 1.0, constant: 20)&#10;        let rightConstraint = NSLayoutConstraint(item: highlightLabel!, attribute: .right, relatedBy: .equal, toItem: containerView, attribute: .right, multiplier: 1.0, constant: -20)&#10;        let topConstraint = NSLayoutConstraint(item: highlightLabel, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1, constant: 20)&#10;        let heiConstraint = NSLayoutConstraint(item: highlightLabel, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: 70)&#10;        &#10;        containerView.addConstraints([leftConstraint, rightConstraint, topConstraint, heiConstraint])&#10;    }&#10;    &#10;    private func configureNavBar() {&#10;        let navBackground = folioReader.isNight(readerConfig.nightModeMenuBackground, UIColor.white)&#10;        let tintColor = readerConfig.tintColor&#10;        let navText = folioReader.isNight(UIColor.white, UIColor.black)&#10;        let font = UIFont(name: &quot;Avenir-Light&quot;, size: 17)!&#10;        setTranslucentNavigation(false, color: navBackground, tintColor: tintColor, titleColor: navText, andFont: font)&#10;        &#10;        let titleAttrs = [NSAttributedString.Key.foregroundColor: readerConfig.tintColor]&#10;        let saveButton = UIBarButtonItem(title: readerConfig.localizedSave, style: .plain, target: self, action: #selector(saveNote(_:)))&#10;        saveButton.setTitleTextAttributes(titleAttrs, for: UIControl.State())&#10;        navigationItem.rightBarButtonItem = saveButton&#10;    }&#10;    &#10;    private func configureKeyboardObserver() {&#10;        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name:UIResponder.keyboardWillShowNotification, object: nil)&#10;        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name:UIResponder.keyboardWillHideNotification, object: nil)&#10;    }&#10;    &#10;    @objc private func keyboardWillShow(notification: NSNotification){&#10;        //give room at the bottom of the scroll view, so it doesn't cover up anything the user needs to tap&#10;        guard let userInfo = notification.userInfo,&#10;              let keyboardFrameValue = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return }&#10;&#10;        var keyboardFrame = keyboardFrameValue.cgRectValue&#10;        keyboardFrame = self.view.convert(keyboardFrame, from: nil)&#10;        &#10;        var contentInset = self.scrollView.contentInset&#10;        contentInset.bottom = keyboardFrame.size.height&#10;        self.scrollView.contentInset = contentInset&#10;        &#10;        // Scroll to make text view visible&#10;        let textViewFrame = self.view.convert(textView.frame, from: containerView)&#10;        let visibleRect = CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height - keyboardFrame.height)&#10;        &#10;        if !visibleRect.contains(textViewFrame) {&#10;            scrollView.scrollRectToVisible(textViewFrame, animated: true)&#10;        }&#10;    }&#10;    &#10;    @objc private func keyboardWillHide(notification:NSNotification){&#10;        let contentInset:UIEdgeInsets = UIEdgeInsets.zero&#10;        self.scrollView.contentInset = contentInset&#10;    }&#10;    &#10;    @objc private func saveNote(_ sender: UIBarButtonItem) {&#10;        do {&#10;            if isEditHighlight {&#10;                let realm = try Realm(configuration: readerConfig.realmConfiguration)&#10;                try realm.write {&#10;                    highlight.noteForHighlight = textView.text&#10;                }&#10;                highlightSaved = true&#10;            } else {&#10;                highlight.noteForHighlight = textView.text&#10;                highlight.persist(withConfiguration: readerConfig)&#10;                highlightSaved = true&#10;            }&#10;&#10;            // Notify that the note was saved successfully&#10;            NotificationCenter.default.post(name: Notification.Name(&quot;HighlightNoteSaved&quot;), object: highlight)&#10;&#10;        } catch let error {&#10;            print(&quot;Error saving note: \(error)&quot;)&#10;            // Show an alert to the user&#10;            let alert = UIAlertController(title: &quot;Error&quot;, message: &quot;Failed to save note. Please try again.&quot;, preferredStyle: .alert)&#10;            alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default))&#10;            present(alert, animated: true)&#10;            return&#10;        }&#10;        &#10;        dismiss(animated: true)&#10;    }&#10;}&#10;&#10;// MARK: - UITextViewDelegate&#10;extension FolioReaderAddHighlightNote: UITextViewDelegate {&#10;    &#10;    func textViewDidChange(_ textView: UITextView) {&#10;        let fixedWidth = textView.frame.size.width&#10;        textView.sizeThatFits(CGSize(width: fixedWidth, height: CGFloat.greatestFiniteMagnitude))&#10;        let newSize = textView.sizeThatFits(CGSize(width: fixedWidth, height: CGFloat.greatestFiniteMagnitude))&#10;        var newFrame = textView.frame&#10;        newFrame.size = CGSize(width: max(newSize.width, fixedWidth), height: newSize.height + 15)&#10;        textView.frame = newFrame;&#10;    }&#10;    &#10;    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool {&#10;        textView.frame.size.height = textView.frame.height + 30&#10;&#10;        if resizedTextView {&#10;            scrollView.scrollRectToVisible(textView.frame, animated: true)&#10;        }&#10;        else{&#10;            resizedTextView = true&#10;        }&#10;        &#10;        return true&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;//  FolioReaderAddHighlightNote.swift&#10;//  FolioReaderKit&#10;//&#10;//  Created by ShuichiNagao on 2018/05/06.&#10;//&#10;&#10;import UIKit&#10;import RealmSwift&#10;&#10;class FolioReaderAddHighlightNote: UIViewController {&#10;&#10;    var textView: UITextView!&#10;    var highlightLabel: UILabel!&#10;    var scrollView: UIScrollView!&#10;    var containerView = UIView()&#10;    var highlight: Highlight!&#10;    var highlightSaved = false&#10;    var isEditHighlight = false&#10;    var resizedTextView = false&#10;    &#10;    private var folioReader: FolioReader&#10;    private var readerConfig: FolioReaderConfig&#10;    &#10;    init(withHighlight highlight: Highlight, folioReader: FolioReader, readerConfig: FolioReaderConfig) {&#10;        self.folioReader = folioReader&#10;        self.highlight = highlight&#10;        self.readerConfig = readerConfig&#10;        &#10;        super.init(nibName: nil, bundle: Bundle.frameworkBundle())&#10;    }&#10;    &#10;    required init?(coder aDecoder: NSCoder) {&#10;        fatalError(&quot;storyboards are incompatible with truth and beauty&quot;)&#10;    }&#10;    &#10;    // MARK: - life cycle methods&#10;    &#10;    override func viewDidLoad() {&#10;        super.viewDidLoad()&#10;        &#10;        setCloseButton(withConfiguration: readerConfig)&#10;        prepareScrollView()&#10;        configureTextView()&#10;        configureLabel()&#10;        configureNavBar()&#10;        configureKeyboardObserver()&#10;    }&#10;    &#10;    override func viewWillAppear(_ animated: Bool) {&#10;        super.viewWillAppear(animated)&#10;        &#10;        textView.becomeFirstResponder()&#10;        setNeedsStatusBarAppearanceUpdate()&#10;    }&#10;    &#10;    override func viewDidLayoutSubviews() {&#10;        super.viewDidLayoutSubviews()&#10;        &#10;        // Make the view more compact by limiting the container size&#10;        let maxHeight: CGFloat = 350 // Total height for highlight + text view + margins&#10;        let containerHeight = min(maxHeight, view.bounds.height * 0.6) // Max 60% of screen&#10;        &#10;        scrollView.frame = view.bounds&#10;        containerView.frame = CGRect(x: 0, y: 0, width: view.bounds.width, height: containerHeight)&#10;        scrollView.contentSize = CGSize(width: view.bounds.width, height: containerHeight)&#10;    }&#10;    &#10;    override func viewWillDisappear(_ animated: Bool) {&#10;        super.viewWillDisappear(animated)&#10;        &#10;        if !highlightSaved &amp;&amp; !isEditHighlight {&#10;            guard let currentPage = folioReader.readerCenter?.currentPage else { return }&#10;            currentPage.webView?.js(&quot;removeThisHighlight()&quot;) { _ in }&#10;        }&#10;    }&#10;    &#10;    // MARK: - private methods&#10;    &#10;    private func prepareScrollView(){&#10;        scrollView = UIScrollView()&#10;        scrollView.delegate = self as UIScrollViewDelegate&#10;        scrollView.contentSize = CGSize.init(width: view.frame.width, height: view.frame.height )&#10;        scrollView.bounces = false&#10;        &#10;        containerView = UIView()&#10;        containerView.backgroundColor = .white&#10;        scrollView.addSubview(containerView)&#10;        view.addSubview(scrollView)&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: scrollView!, attribute: .left, relatedBy: .equal, toItem: view, attribute: .left, multiplier: 1.0, constant: 0)&#10;        let rightConstraint = NSLayoutConstraint(item: scrollView!, attribute: .right, relatedBy: .equal, toItem: view, attribute: .right, multiplier: 1.0, constant: 0)&#10;        let topConstraint = NSLayoutConstraint(item: scrollView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1, constant: 0)&#10;        let botConstraint = NSLayoutConstraint(item: scrollView, attribute: .bottom, relatedBy: .equal, toItem: view, attribute: .bottom, multiplier: 1, constant: 0)&#10;        &#10;        view.addConstraints([leftConstraint, rightConstraint, topConstraint, botConstraint])&#10;    }&#10;    &#10;    private func configureTextView(){&#10;        textView = UITextView()&#10;        textView.delegate = self&#10;        textView.translatesAutoresizingMaskIntoConstraints = false&#10;        textView.textColor = .black&#10;        textView.font = UIFont.boldSystemFont(ofSize: 15)&#10;        containerView.addSubview(textView)&#10;        &#10;        if isEditHighlight {&#10;             textView.text = highlight.noteForHighlight&#10;        }&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: textView!, attribute: .left, relatedBy: .equal, toItem: containerView, attribute: .left, multiplier: 1.0, constant: 20)&#10;        let rightConstraint = NSLayoutConstraint(item: textView!, attribute: .right, relatedBy: .equal, toItem: containerView, attribute: .right, multiplier: 1.0, constant: -20)&#10;        let topConstraint = NSLayoutConstraint(item: textView, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1, constant: 100)&#10;        // Reduce text view height to make the note card more compact&#10;        let heiConstraint = NSLayoutConstraint(item: textView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: 200)&#10;        &#10;        containerView.addConstraints([leftConstraint, rightConstraint, topConstraint, heiConstraint])&#10;    }&#10;    &#10;    private func configureLabel() {&#10;        highlightLabel = UILabel()&#10;        highlightLabel.translatesAutoresizingMaskIntoConstraints = false&#10;        highlightLabel.numberOfLines = 3&#10;        highlightLabel.font = UIFont.systemFont(ofSize: 15)&#10;        highlightLabel.text = highlight.content.stripHtml().truncate(250, trailing: &quot;...&quot;).stripLineBreaks()&#10;        &#10;        containerView.addSubview(self.highlightLabel!)&#10;        &#10;        let leftConstraint = NSLayoutConstraint(item: highlightLabel!, attribute: .left, relatedBy: .equal, toItem: containerView, attribute: .left, multiplier: 1.0, constant: 20)&#10;        let rightConstraint = NSLayoutConstraint(item: highlightLabel!, attribute: .right, relatedBy: .equal, toItem: containerView, attribute: .right, multiplier: 1.0, constant: -20)&#10;        let topConstraint = NSLayoutConstraint(item: highlightLabel, attribute: .top, relatedBy: .equal, toItem: containerView, attribute: .top, multiplier: 1, constant: 20)&#10;        let heiConstraint = NSLayoutConstraint(item: highlightLabel, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1, constant: 70)&#10;        &#10;        containerView.addConstraints([leftConstraint, rightConstraint, topConstraint, heiConstraint])&#10;    }&#10;    &#10;    private func configureNavBar() {&#10;        let navBackground = folioReader.isNight(readerConfig.nightModeMenuBackground, UIColor.white)&#10;        let tintColor = readerConfig.tintColor&#10;        let navText = folioReader.isNight(UIColor.white, UIColor.black)&#10;        let font = UIFont(name: &quot;Avenir-Light&quot;, size: 17)!&#10;        setTranslucentNavigation(false, color: navBackground, tintColor: tintColor, titleColor: navText, andFont: font)&#10;        &#10;        let titleAttrs = [NSAttributedString.Key.foregroundColor: readerConfig.tintColor]&#10;        let saveButton = UIBarButtonItem(title: readerConfig.localizedSave, style: .plain, target: self, action: #selector(saveNote(_:)))&#10;        saveButton.setTitleTextAttributes(titleAttrs, for: UIControl.State())&#10;        navigationItem.rightBarButtonItem = saveButton&#10;    }&#10;    &#10;    private func configureKeyboardObserver() {&#10;        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name:UIResponder.keyboardWillShowNotification, object: nil)&#10;        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name:UIResponder.keyboardWillHideNotification, object: nil)&#10;    }&#10;    &#10;    @objc private func keyboardWillShow(notification: NSNotification){&#10;        //give room at the bottom of the scroll view, so it doesn't cover up anything the user needs to tap&#10;        guard let userInfo = notification.userInfo,&#10;              let keyboardFrameValue = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return }&#10;&#10;        var keyboardFrame = keyboardFrameValue.cgRectValue&#10;        keyboardFrame = self.view.convert(keyboardFrame, from: nil)&#10;        &#10;        var contentInset = self.scrollView.contentInset&#10;        contentInset.bottom = keyboardFrame.size.height&#10;        self.scrollView.contentInset = contentInset&#10;        &#10;        // Scroll to make text view visible&#10;        let textViewFrame = self.view.convert(textView.frame, from: containerView)&#10;        let visibleRect = CGRect(x: 0, y: 0, width: view.bounds.width, height: view.bounds.height - keyboardFrame.height)&#10;        &#10;        if !visibleRect.contains(textViewFrame) {&#10;            scrollView.scrollRectToVisible(textViewFrame, animated: true)&#10;        }&#10;    }&#10;    &#10;    @objc private func keyboardWillHide(notification:NSNotification){&#10;        let contentInset:UIEdgeInsets = UIEdgeInsets.zero&#10;        self.scrollView.contentInset = contentInset&#10;    }&#10;    &#10;    @objc private func saveNote(_ sender: UIBarButtonItem) {&#10;        do {&#10;            if isEditHighlight {&#10;                let realm = try Realm(configuration: readerConfig.realmConfiguration)&#10;                try realm.write {&#10;                    highlight.noteForHighlight = textView.text&#10;                }&#10;                highlightSaved = true&#10;            } else {&#10;                highlight.noteForHighlight = textView.text&#10;                highlight.persist(withConfiguration: readerConfig)&#10;                highlightSaved = true&#10;            }&#10;&#10;            // Notify that the note was saved successfully&#10;            NotificationCenter.default.post(name: Notification.Name(&quot;HighlightNoteSaved&quot;), object: highlight)&#10;&#10;        } catch let error {&#10;            print(&quot;Error saving note: \(error)&quot;)&#10;            // Show an alert to the user&#10;            let alert = UIAlertController(title: &quot;Error&quot;, message: &quot;Failed to save note. Please try again.&quot;, preferredStyle: .alert)&#10;            alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default))&#10;            present(alert, animated: true)&#10;            return&#10;        }&#10;        &#10;        dismiss(animated: true)&#10;    }&#10;}&#10;&#10;// MARK: - UITextViewDelegate&#10;extension FolioReaderAddHighlightNote: UITextViewDelegate {&#10;    &#10;    func textViewDidChange(_ textView: UITextView) {&#10;        let fixedWidth = textView.frame.size.width&#10;        textView.sizeThatFits(CGSize(width: fixedWidth, height: CGFloat.greatestFiniteMagnitude))&#10;        let newSize = textView.sizeThatFits(CGSize(width: fixedWidth, height: CGFloat.greatestFiniteMagnitude))&#10;        var newFrame = textView.frame&#10;        newFrame.size = CGSize(width: max(newSize.width, fixedWidth), height: newSize.height + 15)&#10;        textView.frame = newFrame;&#10;    }&#10;    &#10;    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool {&#10;        textView.frame.size.height = textView.frame.height + 30&#10;&#10;        if resizedTextView {&#10;            scrollView.scrollRectToVisible(textView.frame, animated: true)&#10;        }&#10;        else{&#10;            resizedTextView = true&#10;        }&#10;        &#10;        return true&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>